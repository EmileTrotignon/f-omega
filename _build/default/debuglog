typing unit
Adding unit_0 in env.cvar.
typing bool
Adding bool_0 in env.cvar.
typing int
Adding int_0 in env.cvar.
typing string
Adding string_0 in env.cvar.
typing all #. #
Adding #_0 in env.cvar.
typing #
Adding bot_0 in env.cvar.
typing all #. #
Adding #_0 in env.cvar.
typing #
typing exp : magic
exp : magic has type all #. #
typing lam F :: Type -> Type. all A. F A
Adding F_0 in env.cvar.
typing all A. F A
Adding A_0 in env.cvar.
typing F A
typing F
typing A
Adding forall_0 in env.cvar.
typing lam F :: Type -> Type. exi A. F A
Adding F_0 in env.cvar.
typing exi A. F A
Adding A_0 in env.cvar.
typing F A
typing F
typing A
Adding exists_0 in env.cvar.
typing lam F :: Type -> Type. all A. (all B. F B -> A) -> A
Adding F_0 in env.cvar.
typing all A. (all B. F B -> A) -> A
Adding A_0 in env.cvar.
typing (all B. F B -> A) -> A
typing all B. F B -> A
Adding B_0 in env.cvar.
typing F B -> A
typing F B
typing F
typing B
typing A
typing A
Adding Exi_0 in env.cvar.
typing exp : fun [F :: Type -> Type] [A] (v : F A) =>
  fun [C] (f : all B. F B -> C) => f [A] v
Adding F_0 in env.cvar.
Adding A_0 in env.cvar.
typing F A
typing F
typing A
typing exp : fun [C] (f : all B. F B -> C) => f [A] v
Adding C_0 in env.cvar.
typing all B. F B -> C
Adding B_0 in env.cvar.
typing F B -> C
typing F B
typing F
typing B
typing C
typing exp : f [A] v
typing exp : f
exp : f has type all B. F B -> C
applying all B. F B -> C to A
typing A
Adding B_0 in env.cvar.
applying F B -> C to v
typing exp : v
exp : v has type F A
Could not unify type :
A
with type :
B
