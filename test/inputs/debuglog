Styp : unit became ctyp unit
There does not exists a variable with repr unit in env :

Fresh unit is unit in env :

Styp : bool became ctyp bool
There does not exists a variable with repr bool in env :
 (unit :: Type)
Fresh bool is bool in env :
 (unit :: Type)
Styp : int became ctyp int
There does not exists a variable with repr int in env :
 (bool :: Type) (unit :: Type)
Fresh int is int in env :
 (bool :: Type) (unit :: Type)
Styp : string became ctyp string
There does not exists a variable with repr string in env :
 (bool :: Type) (int :: Type) (unit :: Type)
Fresh string is string in env :
 (bool :: Type) (int :: Type) (unit :: Type)
There does not exists a variable with repr # in env :
 (bool :: Type) (int :: Type) (string :: Type) (unit :: Type)
Fresh # is # in env :
 (bool :: Type) (int :: Type) (string :: Type) (unit :: Type)
Styp : all #. # became ctyp all #. #
There does not exists a variable with repr bot in env :
 (bool :: Type) (int :: Type) (string :: Type) (unit :: Type)
Fresh bot is bot in env :
 (bool :: Type) (int :: Type) (string :: Type) (unit :: Type)
location Characters -1--1:
<dummy loc>

There does not exists a variable with repr # in env :
 (bool :: Type) (bot :: Type) (int :: Type) (string :: Type) (unit :: Type)
Fresh # is # in env :
 (bool :: Type) (bot :: Type) (int :: Type) (string :: Type) (unit :: Type)
Styp : all #. # became ctyp all #. #
adding evar for pattern type
Adding magic : unif in env.evar.
unification for pattern annotation
Trying to unify 
unif
and
all #. #
branch 3
Mentions : Type all #. # doesn't mentions unif
add unification : unif <- all #. #
unifications =  (unif <== all #. #)
Successfully unified 
unif
and
all #. #
into :
all #. #
substs into :all #. #.
typing pattern : magic : all #. # has type all #. #
type_exp_func : magic type to unif1
Trying to unify 
all #. #
and
unif1
branch 4
Mentions : Type all #. # doesn't mentions unif1
add unification : unif1 <- all #. #
unifications =  (unif <== all #. #) (unif1 <== all #. #)
Successfully unified 
all #. #
and
unif1
into :
all #. #
substs into :all #. #.
exp typing : magic
- exp :
magic
- has type :
all #. #
Trying to unify 
all #. #
and
all #. #
branch 12
Subst : # became #
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
Successfully unified 
all #. #
and
all #. #
into :
all #. #
substs into :all #. #.
Hey there, all #. #
adding evar for add_pattern_evar : magic : all #. #
Adding magic : all #. # in env.evar.
adding magic : all #. # : all #. #
There does not exists a variable with repr S in env :
 (bool :: Type) (bot :: Type) (int :: Type) (string :: Type) (unit :: Type)
Fresh S is S in env :
 (bool :: Type) (bot :: Type) (int :: Type) (string :: Type) (unit :: Type)
There does not exists a variable with repr Z in env :
 (S :: Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (string :: Type) (unit :: Type)
Fresh Z is Z in env :
 (S :: Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (string :: Type) (unit :: Type)
Styp : lam S :: Type -> Type. lam Z. Z became ctyp lam S :: Type -> Type. lam Z. Z
There does not exists a variable with repr nat0 in env :
 (bool :: Type) (bot :: Type) (int :: Type) (string :: Type) (unit :: Type)
Fresh nat0 is nat0 in env :
 (bool :: Type) (bot :: Type) (int :: Type) (string :: Type) (unit :: Type)
There does not exists a variable with repr S in env :
 (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
Fresh S is S in env :
 (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
There does not exists a variable with repr Z in env :
 (S :: Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
Fresh Z is Z in env :
 (S :: Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
Styp : lam S :: Type -> Type. lam Z. S Z became ctyp lam S :: Type -> Type. lam Z. S Z
There does not exists a variable with repr nat1 in env :
 (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
Fresh nat1 is nat1 in env :
 (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
There does not exists a variable with repr P in env :
 (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
Fresh P is P in env :
 (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
There does not exists a variable with repr Q in env :
 (P :: (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
Fresh Q is Q in env :
 (P :: (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
There does not exists a variable with repr S in env :
 (P :: (Type -> Type) -> Type -> Type) (Q :: (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
Fresh S is S in env :
 (P :: (Type -> Type) -> Type -> Type) (Q :: (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
There does not exists a variable with repr Z in env :
 (P :: (Type -> Type) -> Type -> Type) (Q :: (Type -> Type) -> Type -> Type) (S :: Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
Fresh Z is Z in env :
 (P :: (Type -> Type) -> Type -> Type) (Q :: (Type -> Type) -> Type -> Type) (S :: Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
Styp : lam P :: (Type -> Type) -> Type -> Type.
  lam Q :: (Type -> Type) -> Type -> Type. lam S :: Type -> Type.
  lam Z.
  P S (Q S Z) became ctyp lam P :: (Type -> Type) -> Type -> Type.
  lam Q :: (Type -> Type) -> Type -> Type. lam S :: Type -> Type.
  lam Z.
  P S (Q S Z)
There does not exists a variable with repr add in env :
 (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
Fresh add is add in env :
 (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
There does not exists a variable with repr P in env :
 (add :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
Fresh P is P in env :
 (add :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
There does not exists a variable with repr Q in env :
 (P :: (Type -> Type) -> Type -> Type) (add :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
Fresh Q is Q in env :
 (P :: (Type -> Type) -> Type -> Type) (add :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
There does not exists a variable with repr S in env :
 (P :: (Type -> Type) -> Type -> Type) (Q :: (Type -> Type) -> Type -> Type) (add :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
Fresh S is S in env :
 (P :: (Type -> Type) -> Type -> Type) (Q :: (Type -> Type) -> Type -> Type) (add :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
There does not exists a variable with repr Z in env :
 (P :: (Type -> Type) -> Type -> Type) (Q :: (Type -> Type) -> Type -> Type) (S :: Type -> Type) (add :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
Fresh Z is Z in env :
 (P :: (Type -> Type) -> Type -> Type) (Q :: (Type -> Type) -> Type -> Type) (S :: Type -> Type) (add :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
Styp : lam P :: (Type -> Type) -> Type -> Type.
  lam Q :: (Type -> Type) -> Type -> Type. lam S :: Type -> Type.
  lam Z.
  P (Q S) Z became ctyp lam P :: (Type -> Type) -> Type -> Type.
  lam Q :: (Type -> Type) -> Type -> Type. lam S :: Type -> Type.
  lam Z.
  P (Q S) Z
There does not exists a variable with repr times in env :
 (add :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
Fresh times is times in env :
 (add :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (string :: Type) (unit :: Type)
There does not exists a variable with repr P in env :
 (add :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (string :: Type) (times :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (unit :: Type)
Fresh P is P in env :
 (add :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (string :: Type) (times :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (unit :: Type)
Styp : lam P :: (Type -> Type) -> Type -> Type. times P P became ctyp lam P :: (Type -> Type) -> Type -> Type. times P P
There does not exists a variable with repr square in env :
 (add :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (string :: Type) (times :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (unit :: Type)
Fresh square is square in env :
 (add :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (string :: Type) (times :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (unit :: Type)
Styp : add nat1 nat1 became ctyp add nat1 nat1
There does not exists a variable with repr nat2 in env :
 (add :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (square :: ((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (string :: Type) (times :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (unit :: Type)
Fresh nat2 is nat2 in env :
 (add :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (square :: ((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (string :: Type) (times :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (unit :: Type)
Styp : square nat2 became ctyp square nat2
There does not exists a variable with repr nat4 in env :
 (add :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (nat2 :: (Type -> Type) -> Type -> Type) (square :: ((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (string :: Type) (times :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (unit :: Type)
Fresh nat4 is nat4 in env :
 (add :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (nat2 :: (Type -> Type) -> Type -> Type) (square :: ((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (string :: Type) (times :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (unit :: Type)
Styp : int became ctyp int
There does not exists a variable with repr z in env :
 (add :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (nat2 :: (Type -> Type) -> Type -> Type) (nat4 :: (Type -> Type) -> Type -> Type) (square :: ((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (string :: Type) (times :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (unit :: Type)
Fresh z is z in env :
 (add :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (nat2 :: (Type -> Type) -> Type -> Type) (nat4 :: (Type -> Type) -> Type -> Type) (square :: ((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (string :: Type) (times :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (unit :: Type)
There does not exists a variable with repr W in env :
 (add :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (nat2 :: (Type -> Type) -> Type -> Type) (nat4 :: (Type -> Type) -> Type -> Type) (square :: ((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (string :: Type) (times :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (unit :: Type) (z :: Type)
Fresh W is W in env :
 (add :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (nat2 :: (Type -> Type) -> Type -> Type) (nat4 :: (Type -> Type) -> Type -> Type) (square :: ((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (string :: Type) (times :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (unit :: Type) (z :: Type)
Styp : lam W. W * W became ctyp lam W. W * W
There does not exists a variable with repr s in env :
 (add :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (nat2 :: (Type -> Type) -> Type -> Type) (nat4 :: (Type -> Type) -> Type -> Type) (square :: ((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (string :: Type) (times :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (unit :: Type) (z :: Type)
Fresh s is s in env :
 (add :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (bool :: Type) (bot :: Type) (int :: Type) (nat0 :: (Type -> Type) -> Type -> Type) (nat1 :: (Type -> Type) -> Type -> Type) (nat2 :: (Type -> Type) -> Type -> Type) (nat4 :: (Type -> Type) -> Type -> Type) (square :: ((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (string :: Type) (times :: ((Type -> Type) -> Type -> Type) ->
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type -> Type) (unit :: Type) (z :: Type)
location File "reduce_T4.fw", line 20, characters 4-9:
check

typing pattern : check has type unif2
Styp : times nat2 nat4 s z became ctyp times nat2 nat4 s z
adding evar for pattern type
Adding x : unif3 in env.evar.
unification for pattern annotation
Trying to unify 
unif3
and
times nat2 nat4 s z
branch 3
Mentions : Type times nat2 nat4 s z doesn't mentions unif3
add unification : unif3 <- times nat2 nat4 s z
unifications =  (unif3 <== times nat2 nat4 s z)
Successfully unified 
unif3
and
times nat2 nat4 s z
into :
times nat2 nat4 s z
substs into :times nat2 nat4 s z.
typing pattern : x : times nat2 nat4 s z has type times nat2 nat4 s z
type_exp_func : fun (x : times nat2 nat4 s z) => x : times nat4 nat2 s z type to times nat2 nat4 s z -> unif4
Trying to unify 
unif2
and
times nat2 nat4 s z -> unif4
branch 3
Mentions : Type times nat2 nat4 s z -> unif4 doesn't mentions unif2
add unification : unif2 <- times nat2 nat4 s z -> unif4
unifications =  (unif2 <== times nat2 nat4 s z -> unif4)
Successfully unified 
unif2
and
times nat2 nat4 s z -> unif4
into :
times nat2 nat4 s z -> unif4
substs into :times nat2 nat4 s z -> unif4.
exp typing : fun (x : times nat2 nat4 s z) => x : times nat4 nat2 s z
Styp : times nat2 nat4 s z became ctyp times nat2 nat4 s z
unification for pattern annotation
Trying to unify 
unif5
and
times nat2 nat4 s z
branch 3
Mentions : Type times nat2 nat4 s z doesn't mentions unif5
add unification : unif5 <- times nat2 nat4 s z
unifications =  (unif2 <== times nat2 nat4 s z -> unif4) (unif5 <== times nat2 nat4 s z)
Successfully unified 
unif5
and
times nat2 nat4 s z
into :
times nat2 nat4 s z
substs into :times nat2 nat4 s z.
typing pattern : x : times nat2 nat4 s z has type times nat2 nat4 s z
Hey there 2, times nat2 nat4 s z
adding evar for add_pattern_evar : x : times nat2 nat4 s z
Adding x : times nat2 nat4 s z in env.evar.
exp typing : x : times nat4 nat2 s z
exp typing : x
- exp :
x
- has type :
times nat2 nat4 s z
Styp : times nat4 nat2 s z became ctyp times nat4 nat2 s z
Trying to unify 
times nat2 nat4 s z
and
times nat4 nat2 s z
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch (Tvar {def= Some {typ; _}; _}), _ | _, (Tvar {def= Some {typ; _}; _})
branch (Tvar {def= Some {typ; _}; _}), _ | _, (Tvar {def= Some {typ; _}; _})
branch 12
Subst : lam Z. S (S (S (S Z))) became lam Z. S (S (S (S Z)))
branch 12
Subst : S (S Z) became S (S Z)
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch (Tapp (_, _), _ | _, Tapp (_, _)) when not !eager
lazy extra normalisation
lazy normalizing :
S (S Z)
into :
S (S Z)
lazy normalizing :
S (S (S Z))
into :
S (S (S Z))
lazy normalizing :
S Z
into :
S Z
lazy normalizing :
S (S (S (S Z)))
into :
S (S (S (S Z)))
lazy normalizing :
S (S Z)
into :
S (S Z)
lazy normalizing :
times nat2
into :
lam Q :: (Type -> Type) -> Type -> Type. lam S :: Type -> Type.
  lam Z.
  nat2 (Q S) Z
lazy normalizing :
times nat4
into :
lam Q :: (Type -> Type) -> Type -> Type. lam S :: Type -> Type.
  lam Z.
  nat4 (Q S) Z
branch 12
Subst : lam S :: Type -> Type. lam Z. nat2 (Q S) Z became lam S :: Type -> Type. lam Z. nat2 (Q S) Z
branch 12
Subst : lam Z. nat4 (Q S) Z became lam Z. nat4 (Q S) Z
branch 12
Subst : nat2 (Q S) Z became nat2 (Q S) Z
branch (Tvar {def= Some {typ; _}; _}), _ | _, (Tvar {def= Some {typ; _}; _})
branch (Tvar {def= Some {typ; _}; _}), _ | _, (Tvar {def= Some {typ; _}; _})
branch 12
Subst : lam Z. S (S Z) became lam Z. S (S Z)
branch 12
Subst : S (S (S (S Z))) became S (S (S (S Z)))
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch (Tapp (_, _), _ | _, Tapp (_, _)) when not !eager
lazy extra normalisation
lazy normalizing :
S (S Z)
into :
S (S Z)
lazy normalizing :
S Z
into :
S Z
lazy normalizing :
S (S (S Z))
into :
S (S (S Z))
lazy normalizing :
S (S Z)
into :
S (S Z)
lazy normalizing :
S (S (S (S Z)))
into :
S (S (S (S Z)))
lazy normalizing :
nat4 (Q S)
into :
lam Z. Q S (Q S (Q S (Q S Z)))
lazy normalizing :
nat2 (Q S)
into :
lam Z. Q S (Q S Z)
branch 12
Subst : Q S (Q S (Q S (Q S Z))) became Q S (Q S (Q S (Q S Z)))
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch (Tapp (_, _), _ | _, Tapp (_, _)) when not !eager
lazy extra normalisation
lazy normalizing :
Q S (Q S Z)
into :
Q S (Q S Z)
lazy normalizing :
Q S Z
into :
Q S Z
lazy normalizing :
Q S (Q S (Q S Z))
into :
Q S (Q S (Q S Z))
lazy normalizing :
Q S (Q S Z)
into :
Q S (Q S Z)
lazy normalizing :
Q S (Q S (Q S (Q S Z)))
into :
Q S (Q S (Q S (Q S Z)))
lazy normalizing :
nat4 (Q S) Z
into :
Q S (Q S (Q S (Q S Z)))
lazy normalizing :
nat2 (Q S) Z
into :
Q S (Q S Z)
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch (Tapp (_, _), _ | _, Tapp (_, _)) when not !eager
lazy extra normalisation
lazy normalizing :
Q S (Q S Z)
into :
Q S (Q S Z)
lazy normalizing :
Q S (Q S (Q S Z))
into :
Q S (Q S (Q S Z))
lazy normalizing :
Q S Z
into :
Q S Z
lazy normalizing :
Q S (Q S (Q S (Q S Z)))
into :
Q S (Q S (Q S (Q S Z)))
lazy normalizing :
Q S (Q S Z)
into :
Q S (Q S Z)
lazy normalizing :
times nat2 nat4
into :
lam S :: Type -> Type. lam Z. nat2 (nat4 S) Z
lazy normalizing :
times nat4 nat2
into :
lam S :: Type -> Type. lam Z. nat4 (nat2 S) Z
branch 12
Subst : lam Z. nat2 (nat4 S) Z became lam Z. nat2 (nat4 S) Z
branch 12
Subst : nat4 (nat2 S) Z became nat4 (nat2 S) Z
branch (Tvar {def= Some {typ; _}; _}), _ | _, (Tvar {def= Some {typ; _}; _})
branch (Tvar {def= Some {typ; _}; _}), _ | _, (Tvar {def= Some {typ; _}; _})
branch 12
Subst : lam Z. S (S (S (S Z))) became lam Z. S (S (S (S Z)))
branch 12
Subst : S (S Z) became S (S Z)
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch (Tapp (_, _), _ | _, Tapp (_, _)) when not !eager
lazy extra normalisation
lazy normalizing :
S (S Z)
into :
S (S Z)
lazy normalizing :
S (S (S Z))
into :
S (S (S Z))
lazy normalizing :
S Z
into :
S Z
lazy normalizing :
S (S (S (S Z)))
into :
S (S (S (S Z)))
lazy normalizing :
S (S Z)
into :
S (S Z)
lazy normalizing :
nat2 (nat4 S)
into :
lam Z. nat4 S (nat4 S Z)
lazy normalizing :
nat4 (nat2 S)
into :
lam Z. nat2 S (nat2 S (nat2 S (nat2 S Z)))
branch 12
Subst : nat4 S (nat4 S Z) became nat4 S (nat4 S Z)
branch (Tvar {def= Some {typ; _}; _}), _ | _, (Tvar {def= Some {typ; _}; _})
branch (Tvar {def= Some {typ; _}; _}), _ | _, (Tvar {def= Some {typ; _}; _})
branch 12
Subst : lam Z. S (S (S (S Z))) became lam Z. S (S (S (S Z)))
branch 12
Subst : S (S Z) became S (S Z)
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch (Tapp (_, _), _ | _, Tapp (_, _)) when not !eager
lazy extra normalisation
lazy normalizing :
S (S Z)
into :
S (S Z)
lazy normalizing :
S (S (S Z))
into :
S (S (S Z))
lazy normalizing :
S Z
into :
S Z
lazy normalizing :
S (S (S (S Z)))
into :
S (S (S (S Z)))
lazy normalizing :
S (S Z)
into :
S (S Z)
lazy normalizing :
nat2 S
into :
lam Z. S (S Z)
lazy normalizing :
nat4 S
into :
lam Z. S (S (S (S Z)))
branch 12
Subst : S (S Z) became S (S Z)
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch (Tapp (_, _), _ | _, Tapp (_, _)) when not !eager
lazy extra normalisation
lazy normalizing :
S (S Z)
into :
S (S Z)
lazy normalizing :
S (S (S Z))
into :
S (S (S Z))
lazy normalizing :
S Z
into :
S Z
lazy normalizing :
S (S (S (S Z)))
into :
S (S (S (S Z)))
lazy normalizing :
S (S Z)
into :
S (S Z)
lazy normalizing :
nat2 S (nat2 S (nat2 S (nat2 S Z)))
into :
S (S (nat2 S (nat2 S (nat2 S Z))))
lazy normalizing :
nat4 S (nat4 S Z)
into :
S (S (S (S (nat4 S Z))))
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch (Tapp (_, _), _ | _, Tapp (_, _)) when not !eager
lazy extra normalisation
lazy normalizing :
nat2 S
into :
lam Z. S (S Z)
failing unification because of shape
lazy normalizing :
nat2 S (nat2 S (nat2 S Z))
into :
S (S (nat2 S (nat2 S Z)))
lazy normalizing :
S (S (nat4 S Z))
into :
S (S (nat4 S Z))
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch (Tvar {def= Some {typ; _}; _}), _ | _, (Tvar {def= Some {typ; _}; _})
branch (Tvar {def= Some {typ; _}; _}), _ | _, (Tvar {def= Some {typ; _}; _})
branch 12
Subst : lam Z. S (S (S (S Z))) became lam Z. S (S (S (S Z)))
branch 12
Subst : S (S Z) became S (S Z)
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch (Tapp (_, _), _ | _, Tapp (_, _)) when not !eager
lazy extra normalisation
lazy normalizing :
S (S Z)
into :
S (S Z)
lazy normalizing :
S (S (S Z))
into :
S (S (S Z))
lazy normalizing :
S Z
into :
S Z
lazy normalizing :
S (S (S (S Z)))
into :
S (S (S (S Z)))
lazy normalizing :
S (S Z)
into :
S (S Z)
lazy normalizing :
nat2 S
into :
lam Z. S (S Z)
lazy normalizing :
nat4 S
into :
lam Z. S (S (S (S Z)))
branch 12
Subst : S (S Z) became S (S Z)
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch (Tapp (_, _), _ | _, Tapp (_, _)) when not !eager
lazy extra normalisation
lazy normalizing :
S (S Z)
into :
S (S Z)
lazy normalizing :
S (S (S Z))
into :
S (S (S Z))
lazy normalizing :
S Z
into :
S Z
lazy normalizing :
S (S (S (S Z)))
into :
S (S (S (S Z)))
lazy normalizing :
S (S Z)
into :
S (S Z)
lazy normalizing :
nat2 S (nat2 S Z)
into :
S (S (nat2 S Z))
lazy normalizing :
nat4 S Z
into :
S (S (S (S Z)))
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch (Tapp (_, _), _ | _, Tapp (_, _)) when not !eager
lazy extra normalisation
lazy normalizing :
nat2 S
into :
lam Z. S (S Z)
failing unification because of shape
lazy normalizing :
nat2 S Z
into :
S (S Z)
lazy normalizing :
S (S Z)
into :
S (S Z)
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
Successfully unified 
times nat2 nat4 s z
and
times nat4 nat2 s z
into :
times nat2 nat4 s z
substs into :times nat2 nat4 s z.
- exp :
x : times nat4 nat2 s z
- has type :
times nat2 nat4 s z
- exp :
fun (x : times nat2 nat4 s z) => x : times nat4 nat2 s z
- has type :
times nat2 nat4 s z -> times nat2 nat4 s z
Trying to unify 
times nat2 nat4 s z -> times nat2 nat4 s z
and
times nat2 nat4 s z -> unif4
branch 11
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch Tvar ident, Tvar ident' when eq_cvar ident ident'
branch 4
Mentions : Type times nat2 nat4 s z doesn't mentions unif4
add unification : unif4 <- times nat2 nat4 s z
unifications =  (unif2 <== times nat2 nat4 s z -> unif4) (unif4 <== times nat2 nat4 s z)
Successfully unified 
times nat2 nat4 s z -> times nat2 nat4 s z
and
times nat2 nat4 s z -> unif4
into :
times nat2 nat4 s z -> times nat2 nat4 s z
substs into :times nat2 nat4 s z -> times nat2 nat4 s z.
Hey there, times nat2 nat4 s z -> times nat2 nat4 s z
adding evar for add_pattern_evar : check : times nat2 nat4 s z -> times nat2 nat4 s z
Adding check : times nat2 nat4 s z -> times nat2 nat4 s z in env.evar.
adding check : times nat2 nat4 s z -> times nat2 nat4 s z
